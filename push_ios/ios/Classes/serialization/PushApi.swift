// Autogenerated from Pigeon (v16.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
    import Flutter
#elseif os(macOS)
    import FlutterMacOS
#else
    #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
    return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
    if let flutterError = error as? FlutterError {
        return [
            flutterError.code,
            flutterError.message,
            flutterError.details,
        ]
    }
    return [
        "\(error)",
        "\(type(of: error))",
        "Stacktrace: \(Thread.callStackSymbols)",
    ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
    return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
    return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
    if value is NSNull { return nil }
    return value as! T?
}

/// # iOS UN (UserNotification) symbols
///
/// Dart/Flutter translation of the iOS permissions API. In a future release,
/// we may replace this API with a consistent API for all platforms that require
/// permissions to show notifications to the user.
/// UNAuthorizationStatus: Constants indicating whether the app is allowed to
/// schedule notifications.
///
/// See the [Apple documentation](https://developer.apple.com/documentation/usernotifications/unnotificationsettings/1648391-authorizationstatus) for more information
enum UNAuthorizationStatus: Int {
    case notDetermined = 0
    case denied = 1
    case authorized = 2
    case provisional = 3
    case ephemeral = 4
}

/// The type of notification the user will see
///
/// See the [Apple documentation](https://developer.apple.com/documentation/usernotifications/unalertstyle) for more information
enum UNAlertStyle: Int {
    case none = 0
    case banner = 1
    case alert = 2
}

/// The current configuration of a notification setting
///
/// See the [Apple documentation](https://developer.apple.com/documentation/usernotifications/unnotificationsetting) for more information
enum UNNotificationSetting: Int {
    case notSupported = 0
    case disabled = 1
    case enabled = 2
}

/// Conditions to show/reveal notification content to the user
///
/// See the [Apple documentation](https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting) for more information
enum UNShowPreviewsSetting: Int {
    case always = 0
    case whenAuthenticated = 1
    case never = 2
}

/// Generated class from Pigeon that represents data sent in messages.
struct RemoteMessage {
    var notification: Notification? = nil
    var data: [String?: Any?]? = nil

    static func fromList(_ list: [Any?]) -> RemoteMessage? {
        var notification: Notification?
        if let notificationList: [Any?] = nilOrValue(list[0]) {
            notification = Notification.fromList(notificationList)
        }
        let data: [String?: Any?]? = nilOrValue(list[1])

        return RemoteMessage(
            notification: notification,
            data: data
        )
    }

    func toList() -> [Any?] {
        return [
            notification?.toList(),
            data,
        ]
    }
}

/// Generated class from Pigeon that represents data sent in messages.
struct Notification {
    var title: String? = nil
    var body: String? = nil

    static func fromList(_ list: [Any?]) -> Notification? {
        let title: String? = nilOrValue(list[0])
        let body: String? = nilOrValue(list[1])

        return Notification(
            title: title,
            body: body
        )
    }

    func toList() -> [Any?] {
        return [
            title,
            body,
        ]
    }
}

/// The object for reading notification-related settings and the authorization status of your app.
///
/// See the [Apple documentation](https://developer.apple.com/documentation/usernotifications/unnotificationsettings) for more information
///
/// Generated class from Pigeon that represents data sent in messages.
struct UNNotificationSettings {
    var authorizationStatus: UNAuthorizationStatus? = nil
    var soundSetting: UNNotificationSetting? = nil
    var badgeSetting: UNNotificationSetting? = nil
    var alertSetting: UNNotificationSetting? = nil
    var notificationCenterSetting: UNNotificationSetting? = nil
    var lockScreenSetting: UNNotificationSetting? = nil
    var carPlaySetting: UNNotificationSetting? = nil
    var alertStyle: UNAlertStyle? = nil
    var showPreviewsSetting: UNShowPreviewsSetting? = nil
    var criticalAlertSetting: UNNotificationSetting? = nil
    var providesAppNotificationSettings: Bool? = nil
    var announcementSetting: UNNotificationSetting? = nil

    static func fromList(_ list: [Any?]) -> UNNotificationSettings? {
        var authorizationStatus: UNAuthorizationStatus?
        let authorizationStatusEnumVal: Int? = nilOrValue(list[0])
        if let authorizationStatusRawValue = authorizationStatusEnumVal {
            authorizationStatus = UNAuthorizationStatus(rawValue: authorizationStatusRawValue)!
        }
        var soundSetting: UNNotificationSetting?
        let soundSettingEnumVal: Int? = nilOrValue(list[1])
        if let soundSettingRawValue = soundSettingEnumVal {
            soundSetting = UNNotificationSetting(rawValue: soundSettingRawValue)!
        }
        var badgeSetting: UNNotificationSetting?
        let badgeSettingEnumVal: Int? = nilOrValue(list[2])
        if let badgeSettingRawValue = badgeSettingEnumVal {
            badgeSetting = UNNotificationSetting(rawValue: badgeSettingRawValue)!
        }
        var alertSetting: UNNotificationSetting?
        let alertSettingEnumVal: Int? = nilOrValue(list[3])
        if let alertSettingRawValue = alertSettingEnumVal {
            alertSetting = UNNotificationSetting(rawValue: alertSettingRawValue)!
        }
        var notificationCenterSetting: UNNotificationSetting?
        let notificationCenterSettingEnumVal: Int? = nilOrValue(list[4])
        if let notificationCenterSettingRawValue = notificationCenterSettingEnumVal {
            notificationCenterSetting = UNNotificationSetting(rawValue: notificationCenterSettingRawValue)!
        }
        var lockScreenSetting: UNNotificationSetting?
        let lockScreenSettingEnumVal: Int? = nilOrValue(list[5])
        if let lockScreenSettingRawValue = lockScreenSettingEnumVal {
            lockScreenSetting = UNNotificationSetting(rawValue: lockScreenSettingRawValue)!
        }
        var carPlaySetting: UNNotificationSetting?
        let carPlaySettingEnumVal: Int? = nilOrValue(list[6])
        if let carPlaySettingRawValue = carPlaySettingEnumVal {
            carPlaySetting = UNNotificationSetting(rawValue: carPlaySettingRawValue)!
        }
        var alertStyle: UNAlertStyle?
        let alertStyleEnumVal: Int? = nilOrValue(list[7])
        if let alertStyleRawValue = alertStyleEnumVal {
            alertStyle = UNAlertStyle(rawValue: alertStyleRawValue)!
        }
        var showPreviewsSetting: UNShowPreviewsSetting?
        let showPreviewsSettingEnumVal: Int? = nilOrValue(list[8])
        if let showPreviewsSettingRawValue = showPreviewsSettingEnumVal {
            showPreviewsSetting = UNShowPreviewsSetting(rawValue: showPreviewsSettingRawValue)!
        }
        var criticalAlertSetting: UNNotificationSetting?
        let criticalAlertSettingEnumVal: Int? = nilOrValue(list[9])
        if let criticalAlertSettingRawValue = criticalAlertSettingEnumVal {
            criticalAlertSetting = UNNotificationSetting(rawValue: criticalAlertSettingRawValue)!
        }
        let providesAppNotificationSettings: Bool? = nilOrValue(list[10])
        var announcementSetting: UNNotificationSetting?
        let announcementSettingEnumVal: Int? = nilOrValue(list[11])
        if let announcementSettingRawValue = announcementSettingEnumVal {
            announcementSetting = UNNotificationSetting(rawValue: announcementSettingRawValue)!
        }

        return UNNotificationSettings(
            authorizationStatus: authorizationStatus,
            soundSetting: soundSetting,
            badgeSetting: badgeSetting,
            alertSetting: alertSetting,
            notificationCenterSetting: notificationCenterSetting,
            lockScreenSetting: lockScreenSetting,
            carPlaySetting: carPlaySetting,
            alertStyle: alertStyle,
            showPreviewsSetting: showPreviewsSetting,
            criticalAlertSetting: criticalAlertSetting,
            providesAppNotificationSettings: providesAppNotificationSettings,
            announcementSetting: announcementSetting
        )
    }

    func toList() -> [Any?] {
        return [
            authorizationStatus?.rawValue,
            soundSetting?.rawValue,
            badgeSetting?.rawValue,
            alertSetting?.rawValue,
            notificationCenterSetting?.rawValue,
            lockScreenSetting?.rawValue,
            carPlaySetting?.rawValue,
            alertStyle?.rawValue,
            showPreviewsSetting?.rawValue,
            criticalAlertSetting?.rawValue,
            providesAppNotificationSettings,
            announcementSetting?.rawValue,
        ]
    }
}

private class PushHostApiCodecReader: FlutterStandardReader {
    override func readValue(ofType type: UInt8) -> Any? {
        switch type {
        case 128:
            return Notification.fromList(readValue() as! [Any?])
        case 129:
            return RemoteMessage.fromList(readValue() as! [Any?])
        case 130:
            return UNNotificationSettings.fromList(readValue() as! [Any?])
        default:
            return super.readValue(ofType: type)
        }
    }
}

private class PushHostApiCodecWriter: FlutterStandardWriter {
    override func writeValue(_ value: Any) {
        if let value = value as? Notification {
            super.writeByte(128)
            super.writeValue(value.toList())
        } else if let value = value as? RemoteMessage {
            super.writeByte(129)
            super.writeValue(value.toList())
        } else if let value = value as? UNNotificationSettings {
            super.writeByte(130)
            super.writeValue(value.toList())
        } else {
            super.writeValue(value)
        }
    }
}

private class PushHostApiCodecReaderWriter: FlutterStandardReaderWriter {
    override func reader(with data: Data) -> FlutterStandardReader {
        return PushHostApiCodecReader(data: data)
    }

    override func writer(with data: NSMutableData) -> FlutterStandardWriter {
        return PushHostApiCodecWriter(data: data)
    }
}

class PushHostApiCodec: FlutterStandardMessageCodec {
    static let shared = PushHostApiCodec(readerWriter: PushHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PushHostApi {
    /// Returns null if it doesn't exist.
    /// See [PushFlutterApi.onNotificationTap] to understand why a RemoteMessage is not provided here.
    func getNotificationTapWhichLaunchedTerminatedApp() throws -> [String?: Any?]?
    func getToken(completion: @escaping (Result<String, Error>) -> Void)
    func backgroundFlutterApplicationReady() throws
    func onListenToOnNewToken() throws
    func onCancelToOnNewToken() throws
    /// Pass true for the option you want permission to use
    /// Returns true if permission was granted.
    func requestPermission(badge: Bool, sound: Bool, alert: Bool, carPlay: Bool, criticalAlert: Bool, provisional: Bool, providesAppNotificationSettings: Bool, announcement: Bool, completion: @escaping (Result<Bool, Error>) -> Void)
    func getNotificationSettings(completion: @escaping (Result<UNNotificationSettings, Error>) -> Void)
    func areNotificationsEnabled(completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
enum PushHostApiSetup {
    /// The codec used by PushHostApi.
    static var codec: FlutterStandardMessageCodec { PushHostApiCodec.shared }
    /// Sets up an instance of `PushHostApi` to handle messages through the `binaryMessenger`.
    static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PushHostApi?) {
        /// Returns null if it doesn't exist.
        /// See [PushFlutterApi.onNotificationTap] to understand why a RemoteMessage is not provided here.
        let getNotificationTapWhichLaunchedTerminatedAppChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.getNotificationTapWhichLaunchedTerminatedApp", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getNotificationTapWhichLaunchedTerminatedAppChannel.setMessageHandler { _, reply in
                do {
                    let result = try api.getNotificationTapWhichLaunchedTerminatedApp()
                    reply(wrapResult(result))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            getNotificationTapWhichLaunchedTerminatedAppChannel.setMessageHandler(nil)
        }
        let getTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.getToken", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getTokenChannel.setMessageHandler { _, reply in
                api.getToken { result in
                    switch result {
                    case let .success(res):
                        reply(wrapResult(res))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            getTokenChannel.setMessageHandler(nil)
        }
        let backgroundFlutterApplicationReadyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.backgroundFlutterApplicationReady", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            backgroundFlutterApplicationReadyChannel.setMessageHandler { _, reply in
                do {
                    try api.backgroundFlutterApplicationReady()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            backgroundFlutterApplicationReadyChannel.setMessageHandler(nil)
        }
        let onListenToOnNewTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.onListenToOnNewToken", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            onListenToOnNewTokenChannel.setMessageHandler { _, reply in
                do {
                    try api.onListenToOnNewToken()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            onListenToOnNewTokenChannel.setMessageHandler(nil)
        }
        let onCancelToOnNewTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.onCancelToOnNewToken", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            onCancelToOnNewTokenChannel.setMessageHandler { _, reply in
                do {
                    try api.onCancelToOnNewToken()
                    reply(wrapResult(nil))
                } catch {
                    reply(wrapError(error))
                }
            }
        } else {
            onCancelToOnNewTokenChannel.setMessageHandler(nil)
        }
        /// Pass true for the option you want permission to use
        /// Returns true if permission was granted.
        let requestPermissionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.requestPermission", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            requestPermissionChannel.setMessageHandler { message, reply in
                let args = message as! [Any?]
                let badgeArg = args[0] as! Bool
                let soundArg = args[1] as! Bool
                let alertArg = args[2] as! Bool
                let carPlayArg = args[3] as! Bool
                let criticalAlertArg = args[4] as! Bool
                let provisionalArg = args[5] as! Bool
                let providesAppNotificationSettingsArg = args[6] as! Bool
                let announcementArg = args[7] as! Bool
                api.requestPermission(badge: badgeArg, sound: soundArg, alert: alertArg, carPlay: carPlayArg, criticalAlert: criticalAlertArg, provisional: provisionalArg, providesAppNotificationSettings: providesAppNotificationSettingsArg, announcement: announcementArg) { result in
                    switch result {
                    case let .success(res):
                        reply(wrapResult(res))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            requestPermissionChannel.setMessageHandler(nil)
        }
        let getNotificationSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.getNotificationSettings", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            getNotificationSettingsChannel.setMessageHandler { _, reply in
                api.getNotificationSettings { result in
                    switch result {
                    case let .success(res):
                        reply(wrapResult(res))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            getNotificationSettingsChannel.setMessageHandler(nil)
        }
        let areNotificationsEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.push_platform_interface.PushHostApi.areNotificationsEnabled", binaryMessenger: binaryMessenger, codec: codec)
        if let api = api {
            areNotificationsEnabledChannel.setMessageHandler { _, reply in
                api.areNotificationsEnabled { result in
                    switch result {
                    case let .success(res):
                        reply(wrapResult(res))
                    case let .failure(error):
                        reply(wrapError(error))
                    }
                }
            }
        } else {
            areNotificationsEnabledChannel.setMessageHandler(nil)
        }
    }
}

private class PushFlutterApiCodecReader: FlutterStandardReader {
    override func readValue(ofType type: UInt8) -> Any? {
        switch type {
        case 128:
            return Notification.fromList(readValue() as! [Any?])
        case 129:
            return RemoteMessage.fromList(readValue() as! [Any?])
        case 130:
            return UNNotificationSettings.fromList(readValue() as! [Any?])
        default:
            return super.readValue(ofType: type)
        }
    }
}

private class PushFlutterApiCodecWriter: FlutterStandardWriter {
    override func writeValue(_ value: Any) {
        if let value = value as? Notification {
            super.writeByte(128)
            super.writeValue(value.toList())
        } else if let value = value as? RemoteMessage {
            super.writeByte(129)
            super.writeValue(value.toList())
        } else if let value = value as? UNNotificationSettings {
            super.writeByte(130)
            super.writeValue(value.toList())
        } else {
            super.writeValue(value)
        }
    }
}

private class PushFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
    override func reader(with data: Data) -> FlutterStandardReader {
        return PushFlutterApiCodecReader(data: data)
    }

    override func writer(with data: NSMutableData) -> FlutterStandardWriter {
        return PushFlutterApiCodecWriter(data: data)
    }
}

class PushFlutterApiCodec: FlutterStandardMessageCodec {
    static let shared = PushFlutterApiCodec(readerWriter: PushFlutterApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol PushFlutterApiProtocol {
    func onMessage(message messageArg: RemoteMessage, completion: @escaping (Result<Void, FlutterError>) -> Void)
    func onBackgroundMessage(message messageArg: RemoteMessage, completion: @escaping (Result<Void, FlutterError>) -> Void)
    /// Unfortunately, the intent provided to the app when a user taps on a
    /// notification does not include notification's title or body.
    /// In this instance, it makes more sense to remove this useful functionality from iOS too.
    /// Only the data property on the RemoteMessage is returned to the user.
    /// This is effectively the lowest common denominator API.
    ///
    /// Hint: You can still include the title, body or other metadata in your
    /// data payload to identify what notification the user tapped on.
    func onNotificationTap(data dataArg: [String?: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void)
    func onNewToken(token tokenArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void)
    func onOpenNotificationSettings(completion: @escaping (Result<Void, FlutterError>) -> Void)
}

class PushFlutterApi: PushFlutterApiProtocol {
    private let binaryMessenger: FlutterBinaryMessenger
    init(binaryMessenger: FlutterBinaryMessenger) {
        self.binaryMessenger = binaryMessenger
    }

    var codec: FlutterStandardMessageCodec {
        return PushFlutterApiCodec.shared
    }

    func onMessage(message messageArg: RemoteMessage, completion: @escaping (Result<Void, FlutterError>) -> Void) {
        let channelName = "dev.flutter.pigeon.push_platform_interface.PushFlutterApi.onMessage"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([messageArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(FlutterError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onBackgroundMessage(message messageArg: RemoteMessage, completion: @escaping (Result<Void, FlutterError>) -> Void) {
        let channelName = "dev.flutter.pigeon.push_platform_interface.PushFlutterApi.onBackgroundMessage"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([messageArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(FlutterError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    /// Unfortunately, the intent provided to the app when a user taps on a
    /// notification does not include notification's title or body.
    /// In this instance, it makes more sense to remove this useful functionality from iOS too.
    /// Only the data property on the RemoteMessage is returned to the user.
    /// This is effectively the lowest common denominator API.
    ///
    /// Hint: You can still include the title, body or other metadata in your
    /// data payload to identify what notification the user tapped on.
    func onNotificationTap(data dataArg: [String?: Any?], completion: @escaping (Result<Void, FlutterError>) -> Void) {
        let channelName = "dev.flutter.pigeon.push_platform_interface.PushFlutterApi.onNotificationTap"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([dataArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(FlutterError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onNewToken(token tokenArg: String, completion: @escaping (Result<Void, FlutterError>) -> Void) {
        let channelName = "dev.flutter.pigeon.push_platform_interface.PushFlutterApi.onNewToken"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage([tokenArg] as [Any?]) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(FlutterError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }

    func onOpenNotificationSettings(completion: @escaping (Result<Void, FlutterError>) -> Void) {
        let channelName = "dev.flutter.pigeon.push_platform_interface.PushFlutterApi.onOpenNotificationSettings"
        let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
        channel.sendMessage(nil) { response in
            guard let listResponse = response as? [Any?] else {
                completion(.failure(createConnectionError(withChannelName: channelName)))
                return
            }
            if listResponse.count > 1 {
                let code: String = listResponse[0] as! String
                let message: String? = nilOrValue(listResponse[1])
                let details: String? = nilOrValue(listResponse[2])
                completion(.failure(FlutterError(code: code, message: message, details: details)))
            } else {
                completion(.success(()))
            }
        }
    }
}
